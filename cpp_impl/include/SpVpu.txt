Old SVPU desc:
 /*- Sparse Vector Processing Unit *-/
 * Similar to STPU paper, slightly modified
 *
 * mac_t should be a mac_t_p<b>
 *
 * VPU shaped specified a priori: NxN
 *
 * Full implementation in header to avoid nttp
 * 
 * Though not explicitly mentioned, this VPU
 * also operates in a HSA-style dataflow (stationary
 * weights).
 *
 * How it works:
 * 
 * We want to multiply W*x, where x is some vector.
 * W here is taken to be a sparse matrix, for example:
 * | 5 0 1 1 |
 * | 0 4 0 1 |
 * | 0 2 5 0 |
 * | 1 0 0 0 |
 *
 * We then perform column merging (in sw) to produce:
 * | 5,1  1,3 |
 * | 4,2  1,4 |
 * | 2,2  5,3 |
 * | 1,1  0,3 |
 *
 * Notice that we tag which column each one came from.
 * Suppose x = <4, 8, 12, 16>. We assume to broadcast
 * the activation value (** NOTE: THIS DIFFERS FROM THE
 * PAPER I MENTIONED IN THE PROPOSAL - STPU by He. et al.
 * WHERE THEY PIPELINE ACTIVATION ACROSS, BUT I DO THIS
 * FOR BETTER COMPARISON WITH HSA **) to each row of our
 * SpMAC units. Each SpMAC unit holds its weight, the
 * weight index, and a 'hold' register, whose use will
 * become apparent below.
 *
 * So, in the first cycle, 4 is broadcast to the top two
 * mac units. They then multiply to produce 20 and 4
 * respectively, and pass this down to the next MAC ALONG
 * with the weight index.
 *
 * Cycle 2: In this case, both will fail the index comparison test.
 * Because of this, the newly broadcast value of 8 has to be
 * held in the 'activation hold register', and then the
 * partial sums from above are directly bypassed to the next MAC
 * (essentially, we don't need to operate here because it is
 * as if we were adding a multiply by zero)
 *
 * Cycle 3: Now, 12 is broadcast. In the first column, the same case
 * as in cycle 2 is observed, 12 is saved to a register and the 
 * partial sum bypassed. In the second column, however, there is an index
 * match. This means that we multiply and accumulate with the inputted
 * partial sum to make 12*5 + 4 = 21. Moreover, the activation value
 * is NOT put in the hold register (we won't need it, once a PE
 * has one index match, it cannot have anymore!)
 * At each cycle (except first and last) there are two rows active. In this case
 * it is rows 2 and 3 (in cycle 2 row 1 was also active, but nothing
 * interesting happened because activation hold was empty). However, in this cycle
 * both MACs in row 2 have activation holds. This means they now perform
 * a multiply accumulate taking the partial sum of zero as input,
 * so the values 4*8=32 and 1*8=8 tagged with 2 and 4 respectively are produced
 * and passed down.
 *
 * Cycle 4: Remember in cycle 3 we held the activation value of 12 in the
 * first column. Now that there is an index match with the partial sum
 * 32,2, we multiply accumulate: 32+2*12 = 56, empty the act hold and pass this
 * down. In row 3 column 2 there is a index mismatch (obviously, as this
 * is second pass and we already emptied our act hold reg / used broadcast value)
 * In row 4, the value 16 is broadcast and we have a double tag match
 * leading to 20+16=36 being produced and 21+0 = 21.
 *
 * Cycle 5: Two index mismatches, so two bypasses, produce 56 and 8 respectively
 *
 * I am now realising that this is wrong, and actually,
 * I pass partial sums left to right and always accumulate.
 * Instead, I broadcast to each column as follows:
 * Cycle 1: broadcast 4 to col 1
 * Cycle 2: broadcast 8 to col 1
 * Cycle 3: broadcast 12 to col 2
 * Cycle 4: broadcast 16 to col 2
 *
 * I accumulate locally and then pass the partial sum
 * to the next column once I finish the broadcasts to column 1.
 */ 
